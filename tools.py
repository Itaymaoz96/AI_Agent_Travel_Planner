"""
Tools: OpenAI schemas, weather/places implementations, and tool registry.
"""

import json
import threading
from collections import defaultdict
from typing import Callable

import requests

from config import (
    NOMINATIM_URL,
    OPENWEATHER_API_KEY,
    OPENWEATHER_FORECAST_URL,
    OPENWEATHER_URL,
    PLACE_CATEGORIES,
    OVERPASS_URL,
    REQUEST_HEADERS,
)

# --- OpenAI tool schemas ---

WEATHER_TOOL = {
    "type": "function",
    "function": {
        "name": "get_current_temperature",
        "description": "Get the current temperature for a given city or location. Use when the user asks about current weather or for same-day trip planning. For a trip starting today in one city, you may call both get_current_temperature and get_weather_forecast for that city in the same round (they run in parallel). If the user DOES NOT ask clearly about weather, DO NOT use this tool; ask for clarification if needed.",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "City name, e.g. 'London', 'New York', or 'Tokyo, Japan'",
                }
            },
            "required": ["location"],
        },
    },
}

PLACES_TOOL = {
    "type": "function",
    "function": {
        "name": "search_places",
        "description": (
            "Search only for restaurants, museums, or parks near a location (Overpass/OSM). "
            "Use ONLY for these three categories. All other POIs and trip attractions (sights, landmarks, cafes, bars, etc.) must be generated by you from your own knowledge—do not call this tool for them. "
            "Trip planning flow: (1) Call get_weather_forecast (or get_current_temperature for same-day) FIRST for the destination. "
            "(2) Based on weather: if rainy or poor conditions, call search_places only for 'restaurant' and 'museum'. "
            "If weather allows (clear, mild, no heavy rain), also call search_places for 'park'. "
            "Call all applicable search_places in one round (same city, different category) so they run in parallel. "
            "Then build the full itinerary using these results plus your own suggestions for other attractions. "
            "Do not list the same place on more than one day."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "City or area to search (e.g. 'London', 'Paris', 'Tokyo')",
                },
                "category": {
                    "type": "string",
                    "description": "Must be one of: restaurant, museum, park. Other POI types are not supported by this API.",
                    "enum": ["restaurant", "museum", "park"],
                    "default": "restaurant",
                },
                "limit": {
                    "type": "integer",
                    "description": "Max results per category (default 10). Use 15–20 for trip planning.",
                    "default": 10,
                },
            },
            "required": ["location"],
        },
    },
}

WEATHER_FORECAST_TOOL = {
    "type": "function",
    "function": {
        "name": "get_weather_forecast",
        "description": "Get weather forecast for a city or location. Use get_current_temperature for right-now weather only. For a multi-day trip to one city, call ONCE with days set to the trip length (e.g. 3-day trip -> days=3, offset_days=0). For a multi-city trip, call get_weather_forecast once per city in the same round (all calls run simultaneously)—each with days = number of days in that city or full trip length if unclear. Do not call once per day. Single-day: (1) one specific day -> offset_days and days=1; (2) a range -> offset_days=0, days=N. This tool only supports the next 5 days (today through 4 days from now); if the user asks for later dates, do NOT call—explain the limit and do not make up weather.",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "City or place name, e.g. 'London', 'Paris', 'Tokyo, Japan'",
                },
                "days": {
                    "type": "integer",
                    "description": "Number of days to return: 1 for a single day (e.g. 'in two days'), or 2-5 for a range (e.g. 'next 4 days'). Default 5.",
                    "default": 5,
                },
                "offset_days": {
                    "type": "integer",
                    "description": "Which day to start from: 0=today, 1=tomorrow, 2=in 2 days, 3=in 3 days, 4=in 4 days. Use 0 for 'next N days' or 'this week'. Use 2 for 'in two days'. Default 0.",
                    "default": 0,
                },
            },
            "required": ["location"],
        },
    },
}

# --- Weather implementation ---


def get_current_temperature(location: str) -> str:
    """Fetch current temperature for a location using OpenWeather API."""
    if not OPENWEATHER_API_KEY:
        return json.dumps({"error": "OpenWeather API key not configured. Add OPENWEATHER_API_KEY to .env"})

    params = {
        "q": location,
        "appid": OPENWEATHER_API_KEY,
        "units": "metric",
    }
    try:
        resp = requests.get(OPENWEATHER_URL, params=params, timeout=5)
        data = resp.json()

        if resp.status_code != 200:
            return json.dumps({"error": data.get("message", "Unknown API error")})

        temp = data.get("main", {}).get("temp")
        feels_like = data.get("main", {}).get("feels_like")
        desc = data.get("weather", [{}])[0].get("description", "N/A")
        city = data.get("name", location)
        country = data.get("sys", {}).get("country", "")

        result = {
            "location": f"{city}, {country}" if country else city,
            "temperature_celsius": temp,
            "feels_like_celsius": feels_like,
            "description": desc,
        }
        return json.dumps(result)
    except requests.RequestException as e:
        return json.dumps({"error": str(e)})


def get_weather_forecast(location: str, days: int = 5, offset_days: int = 0) -> str:
    """
    Fetch weather forecast for a location. offset_days=0 is today, 1=tomorrow, etc.
    Returns one summary per day (date, min/max temp, description, precipitation chance).
    """
    days = max(1, min(5, days))
    offset_days = max(0, min(4, offset_days))
    if not OPENWEATHER_API_KEY:
        return json.dumps({"error": "OpenWeather API key not configured. Add OPENWEATHER_API_KEY to .env"})

    params = {
        "q": location,
        "appid": OPENWEATHER_API_KEY,
        "units": "metric",
    }
    try:
        resp = requests.get(OPENWEATHER_FORECAST_URL, params=params, timeout=5)
        data = resp.json()

        if resp.status_code != 200:
            return json.dumps({"error": data.get("message", "Unknown API error")})

        city = data.get("city", {}).get("name", location)
        country = data.get("city", {}).get("country", "")
        location_str = f"{city}, {country}" if country else city
        items = data.get("list", [])

        by_day = defaultdict(list)
        for entry in items:
            dt_txt = entry.get("dt_txt", "")
            if not dt_txt:
                continue
            day_key = dt_txt.split()[0]
            by_day[day_key].append(entry)

        sorted_days = sorted(by_day.keys())
        forecast = []
        for day_key in sorted_days[offset_days : offset_days + days]:
            entries = by_day[day_key]
            temps = [e.get("main", {}).get("temp") for e in entries if e.get("main", {}).get("temp") is not None]
            descs = [e.get("weather", [{}])[0].get("description") for e in entries if e.get("weather")]
            pops = [e.get("pop") for e in entries if e.get("pop") is not None]
            forecast.append({
                "date": day_key,
                "temp_min_celsius": min(temps) if temps else None,
                "temp_max_celsius": max(temps) if temps else None,
                "description": max(set(descs), key=descs.count) if descs else "N/A",
                "precipitation_chance_percent": round(100 * max(pops)) if pops else None,
            })
        return json.dumps({
            "location": location_str,
            "forecast": forecast,
            "count": len(forecast),
        })
    except requests.RequestException as e:
        return json.dumps({"error": str(e)})
    except Exception as e:
        return json.dumps({"error": str(e)})

# --- Places implementation ---

_geocode_cache: dict[str, tuple[float, float] | None] = {}
_geocode_lock = threading.Lock()
OVERPASS_CATEGORIES = frozenset(PLACE_CATEGORIES.keys())


def _geocode(location: str) -> tuple[float, float] | None:
    """Resolve a place name to (lat, lon) using Nominatim."""
    key = location.strip().lower() if location else ""
    with _geocode_lock:
        if key in _geocode_cache:
            return _geocode_cache[key]
        try:
            r = requests.get(
                NOMINATIM_URL,
                params={"q": location, "format": "json", "limit": 1},
                headers=REQUEST_HEADERS,
                timeout=10,
            )
            if r.status_code != 200:
                result = None
            else:
                data = r.json()
                if not data:
                    result = None
                else:
                    result = float(data[0]["lat"]), float(data[0]["lon"])
        except Exception:
            result = None
        _geocode_cache[key] = result
        return result


def search_places(
    location: str,
    category: str | None = None,
    limit: int = 10,
) -> str:
    """Search for restaurants, museums, or parks near a location via Overpass (OSM)."""
    try:
        coords = _geocode(location)
        if not coords:
            return json.dumps({"error": f"Could not find location: {location}"})

        lat, lon = coords
        radius_m = 5000
        cat = (category or "restaurant").lower().strip()
        if cat not in OVERPASS_CATEGORIES:
            return json.dumps({
                "error": f"Category must be one of: {sorted(OVERPASS_CATEGORIES)}. Other POIs are generated by the assistant."
            })
        osm_filter = PLACE_CATEGORIES[cat]

        overpass = f"""[out:json][timeout:20];
        (
         node{osm_filter}(around:{radius_m},{lat},{lon});
         way{osm_filter}(around:{radius_m},{lat},{lon});
        );
        out center tags;
        >;
        out qt;"""

        r = requests.post(
            OVERPASS_URL,
            data={"data": overpass},
            headers=REQUEST_HEADERS,
            timeout=20,
        )
        if r.status_code != 200:
            return json.dumps({"error": f"Overpass API error: {r.status_code}"})

        data = r.json()
        elements = data.get("elements", [])

        results = []
        seen_names: set[str] = set()
        for el in elements:
            tags = el.get("tags", {})
            name = tags.get("name") or tags.get("brand") or "Unnamed"
            if not name or name in seen_names:
                continue
            seen_names.add(name)
            if "center" in el:
                lat_, lon_ = el["center"].get("lat"), el["center"].get("lon")
            else:
                lat_, lon_ = el.get("lat"), el.get("lon")
            if lat_ is None or lon_ is None:
                continue
            addr = tags.get("addr:street") or tags.get("address") or ""
            if tags.get("addr:housenumber"):
                addr = f"{tags.get('addr:housenumber', '')} {addr}".strip()
            results.append({
                "name": name,
                "category": tags.get("amenity") or tags.get("tourism") or tags.get("leisure") or cat,
                "address": addr or None,
                "lat": lat_,
                "lon": lon_,
            })
            if len(results) >= limit:
                break

        if not results:
            return json.dumps({"message": f"No {cat} places found near {location}.", "places": []})
        return json.dumps({"places": results, "count": len(results), "location": location})
    except requests.RequestException as e:
        return json.dumps({"error": str(e)})
    except Exception as e:
        return json.dumps({"error": str(e)})

# --- Tool registry ---


class ToolRegistry:
    """Maps tool name -> (schema, callable). Run tools by name without branching in callers."""

    def __init__(self) -> None:
        self._tools: dict[str, tuple[dict, Callable[..., str]]] = {}

    def register(self, name: str, schema: dict, fn: Callable[..., str]) -> None:
        self._tools[name] = (schema, fn)

    def get_schemas(self) -> list[dict]:
        """Return list of OpenAI tool schemas in registration order."""
        return [schema for schema, _ in self._tools.values()]

    def run(self, name: str, args: dict) -> str:
        """Execute tool by name; return raw JSON string result."""
        if name not in self._tools:
            return json.dumps({"error": f"Unknown tool: {name}"})
        _, fn = self._tools[name]
        return fn(**args)


def create_default_registry() -> ToolRegistry:
    """Build registry with weather and places tools."""
    reg = ToolRegistry()
    reg.register(
        "get_current_temperature",
        WEATHER_TOOL,
        lambda **kw: get_current_temperature(kw.get("location", "")),
    )
    reg.register(
        "get_weather_forecast",
        WEATHER_FORECAST_TOOL,
        lambda **kw: get_weather_forecast(
            location=kw.get("location", ""),
            days=kw.get("days", 5),
            offset_days=kw.get("offset_days", 0),
        ),
    )
    reg.register(
        "search_places",
        PLACES_TOOL,
        lambda **kw: search_places(
            location=kw.get("location", ""),
            category=kw.get("category", "restaurant"),
            limit=kw.get("limit", 10),
        ),
    )
    return reg


tool_registry = create_default_registry()
